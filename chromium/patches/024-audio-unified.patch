diff --git a/third_party/blink/renderer/modules/webaudio/analyser_node.cc b/third_party/blink/renderer/modules/webaudio/analyser_node.cc
index 1111111..2222222 100644
--- a/third_party/blink/renderer/modules/webaudio/analyser_node.cc
+++ b/third_party/blink/renderer/modules/webaudio/analyser_node.cc
@@ -28,6 +28,10 @@
 #include "third_party/blink/renderer/modules/webaudio/base_audio_context.h"
 #include "third_party/blink/renderer/platform/bindings/exception_state.h"

+// Fingerprint protection integration
+#include "content/browser/fingerprint/fingerprint_session_manager.h"
+#include <random>
+

 namespace blink {

@@ -180,6 +184,56 @@ void AnalyserHandler::Process(uint32_t frames_to_process) {
   output_bus->CopyFrom(*input_bus);
 }

+// =============================================================================
+// AUDIO FINGERPRINT PROTECTION
+// Uses FingerprintSessionManager for unified configuration
+// =============================================================================
+
+namespace {
+
+// Add noise to float audio data (frequency domain)
+void AddAudioFloatNoise(float* data, size_t size) {
+  auto& session = content::FingerprintSessionManager::GetInstance();
+
+  float noise_level = session.GetAudioAnalyserNoise();
+  uint64_t seed = session.GetSessionSeed();
+
+  if (noise_level <= 0) {
+    return;
+  }
+
+  // Use deterministic seed for consistent results
+  std::mt19937_64 gen(seed + 0x41554449);  // "AUDI" offset
+  std::uniform_real_distribution<float> dist(-noise_level, noise_level);
+
+  for (size_t i = 0; i < size; i++) {
+    data[i] += dist(gen);
+  }
+}
+
+// Add noise to byte audio data (time domain)
+void AddAudioByteNoise(uint8_t* data, size_t size) {
+  auto& session = content::FingerprintSessionManager::GetInstance();
+
+  float noise_level = session.GetAudioAnalyserNoise();
+  uint64_t seed = session.GetSessionSeed();
+
+  if (noise_level <= 0) {
+    return;
+  }
+
+  std::mt19937_64 gen(seed + 0x42595445);  // "BYTE" offset
+  std::uniform_int_distribution<int> dist(-1, 1);
+
+  // Only modify ~1% of values to be subtle
+  size_t noise_count = size / 100;
+  for (size_t i = 0; i < noise_count; i++) {
+    size_t idx = gen() % size;
+    int val = static_cast<int>(data[idx]) + dist(gen);
+    if (val < 0) val = 0;
+    if (val > 255) val = 255;
+    data[idx] = static_cast<uint8_t>(val);
+  }
+}
+
+}  // namespace

 void AnalyserHandler::SetFftSize(unsigned size,
                                  ExceptionState& exception_state) {
@@ -234,6 +288,10 @@ void AnalyserNode::getFloatFrequencyData(NotShared<DOMFloat32Array> array) {
   if (!array)
     return;
   analyser_handler_->GetFloatFrequencyData(array->Data(), array->length());
+
+  // ==========================================================================
+  // AUDIO FINGERPRINT PROTECTION
+  // ==========================================================================
+  AddAudioFloatNoise(array->Data(), array->length());
 }

 void AnalyserNode::getByteFrequencyData(NotShared<DOMUint8Array> array) {
@@ -241,6 +299,8 @@ void AnalyserNode::getByteFrequencyData(NotShared<DOMUint8Array> array) {
   if (!array)
     return;
   analyser_handler_->GetByteFrequencyData(array->Data(), array->length());
+
+  AddAudioByteNoise(array->Data(), array->length());
 }

 void AnalyserNode::getFloatTimeDomainData(NotShared<DOMFloat32Array> array) {
@@ -248,6 +308,8 @@ void AnalyserNode::getFloatTimeDomainData(NotShared<DOMFloat32Array> array) {
   if (!array)
     return;
   analyser_handler_->GetFloatTimeDomainData(array->Data(), array->length());
+
+  AddAudioFloatNoise(array->Data(), array->length());
 }

 void AnalyserNode::getByteTimeDomainData(NotShared<DOMUint8Array> array) {
@@ -255,6 +317,8 @@ void AnalyserNode::getByteTimeDomainData(NotShared<DOMUint8Array> array) {
   if (!array)
     return;
   analyser_handler_->GetByteTimeDomainData(array->Data(), array->length());
+
+  AddAudioByteNoise(array->Data(), array->length());
 }

 }  // namespace blink

diff --git a/third_party/blink/renderer/modules/webaudio/oscillator_node.cc b/third_party/blink/renderer/modules/webaudio/oscillator_node.cc
index 3333333..4444444 100644
--- a/third_party/blink/renderer/modules/webaudio/oscillator_node.cc
+++ b/third_party/blink/renderer/modules/webaudio/oscillator_node.cc
@@ -32,6 +32,10 @@
 #include "third_party/blink/renderer/platform/audio/audio_utilities.h"
 #include "third_party/blink/renderer/platform/bindings/exception_state.h"

+// Fingerprint protection integration
+#include "content/browser/fingerprint/fingerprint_session_manager.h"
+#include <random>
+

 namespace blink {

@@ -178,6 +182,32 @@ bool OscillatorHandler::PropagatesSilence() const {
   return !IsPlayingOrScheduled() || HasFinished();
 }

+// =============================================================================
+// OSCILLATOR FINGERPRINT PROTECTION
+// Add imperceptible frequency variation
+// =============================================================================
+
+namespace {
+
+float GetOscillatorFrequencyNoise() {
+  auto& session = content::FingerprintSessionManager::GetInstance();
+
+  float noise_level = session.GetAudioOscillatorNoise();
+  uint64_t seed = session.GetSessionSeed();
+
+  if (noise_level <= 0) {
+    return 0.0f;
+  }
+
+  // Thread-local generator for performance
+  thread_local std::mt19937_64 gen(seed + 0x4F534349);  // "OSCI" offset
+  std::uniform_real_distribution<float> dist(-noise_level, noise_level);
+
+  return dist(gen);
+}
+
+}  // namespace

 void OscillatorHandler::Process(uint32_t frames_to_process) {
   AudioBus* output_bus = Output(0).Bus();
@@ -215,6 +245,10 @@ void OscillatorHandler::Process(uint32_t frames_to_process) {
   for (unsigned i = 0; i < frames_to_process; ++i) {
     float frequency = narrow_cast<float>(frequency_values[i]);

+    // ==========================================================================
+    // OSCILLATOR FINGERPRINT PROTECTION
+    // Apply imperceptible frequency variation
+    // ==========================================================================
+    frequency *= (1.0f + GetOscillatorFrequencyNoise());
+
     // Calculate the sample value
     float sample;
     if (type_ == OscillatorType::kSine) {

diff --git a/third_party/blink/renderer/modules/webaudio/dynamics_compressor_node.cc b/third_party/blink/renderer/modules/webaudio/dynamics_compressor_node.cc
index 5555555..6666666 100644
--- a/third_party/blink/renderer/modules/webaudio/dynamics_compressor_node.cc
+++ b/third_party/blink/renderer/modules/webaudio/dynamics_compressor_node.cc
@@ -30,6 +30,10 @@
 #include "third_party/blink/renderer/platform/audio/dynamics_compressor.h"
 #include "third_party/blink/renderer/platform/bindings/exception_state.h"

+// Fingerprint protection integration
+#include "content/browser/fingerprint/fingerprint_session_manager.h"
+#include <random>
+

 namespace blink {

@@ -156,8 +160,33 @@ void DynamicsCompressorHandler::Process(uint32_t frames_to_process) {
                               frames_to_process);
 }

+// =============================================================================
+// DYNAMICS COMPRESSOR FINGERPRINT PROTECTION
+// Add noise to reduction value
+// =============================================================================
+
+namespace {
+
+float GetCompressorReductionNoise() {
+  auto& session = content::FingerprintSessionManager::GetInstance();
+
+  float noise_level = session.GetAudioCompressorNoise();
+  uint64_t seed = session.GetSessionSeed();
+
+  if (noise_level <= 0) {
+    return 0.0f;
+  }
+
+  thread_local std::mt19937_64 gen(seed + 0x434F4D50);  // "COMP" offset
+  std::uniform_real_distribution<float> dist(-noise_level, noise_level);
+
+  return dist(gen);
+}
+
+}  // namespace
+
 float DynamicsCompressorHandler::ReductionValue() const {
-  return reduction_;
+  // Apply subtle noise to reduction value for fingerprint protection
+  float reduction = reduction_;
+  if (reduction != 0.0f) {
+    reduction *= (1.0f + GetCompressorReductionNoise());
+  }
+  return reduction;
 }

diff --git a/third_party/blink/renderer/modules/webaudio/offline_audio_context.cc b/third_party/blink/renderer/modules/webaudio/offline_audio_context.cc
index 7777777..8888888 100644
--- a/third_party/blink/renderer/modules/webaudio/offline_audio_context.cc
+++ b/third_party/blink/renderer/modules/webaudio/offline_audio_context.cc
@@ -34,6 +34,10 @@
 #include "third_party/blink/renderer/platform/bindings/exception_state.h"
 #include "third_party/blink/renderer/platform/heap/persistent.h"

+// Fingerprint protection integration
+#include "content/browser/fingerprint/fingerprint_session_manager.h"
+#include <random>
+

 namespace blink {

@@ -189,6 +193,42 @@ void OfflineAudioContext::DidSuspend(ScriptPromiseResolver* resolver) {
   resolver->Resolve();
 }

+// =============================================================================
+// OFFLINE AUDIO CONTEXT FINGERPRINT PROTECTION
+// Add noise to rendered audio buffer
+// =============================================================================
+
+namespace {
+
+void AddOfflineAudioNoise(AudioBuffer* buffer) {
+  if (!buffer)
+    return;
+
+  auto& session = content::FingerprintSessionManager::GetInstance();
+
+  float noise_level = session.GetAudioAnalyserNoise();
+  uint64_t seed = session.GetSessionSeed();
+
+  if (noise_level <= 0)
+    return;
+
+  std::mt19937_64 gen(seed + 0x4F46464C);  // "OFFL" offset
+  std::uniform_real_distribution<float> dist(-noise_level * 0.1f, noise_level * 0.1f);
+
+  for (unsigned channel = 0; channel < buffer->numberOfChannels(); ++channel) {
+    DOMFloat32Array* channel_data = buffer->getChannelData(channel);
+    if (!channel_data)
+      continue;
+
+    float* data = channel_data->Data();
+    size_t length = channel_data->length();
+
+    for (size_t i = 0; i < length; ++i) {
+      data[i] += dist(gen);
+    }
+  }
+}
+
+}  // namespace

 void OfflineAudioContext::DidFinishRendering(AudioBuffer* rendered_buffer) {
   DCHECK(IsMainThread());
@@ -201,6 +241,11 @@ void OfflineAudioContext::DidFinishRendering(AudioBuffer* rendered_buffer) {
   // Return early if the rendering was aborted.
   if (!is_rendering_started_)
     return;

+  // ==========================================================================
+  // OFFLINE AUDIO FINGERPRINT PROTECTION
+  // ==========================================================================
+  AddOfflineAudioNoise(rendered_buffer);
+
   // All promises are resolved at once. If the result is null, they will all
   // reject.
