diff --git a/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc b/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc
index aaaaaaa..bbbbbbb 100644
--- a/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc
+++ b/third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.cc
@@ -85,6 +85,10 @@
 #include "ui/gl/gpu_preference.h"
 #include "v8/include/v8.h"

+// Fingerprint protection integration
+#include "content/browser/fingerprint/fingerprint_session_manager.h"
+#include <random>
+

 namespace blink {

@@ -2150,6 +2154,89 @@ void WebGLRenderingContextBase::ClearIfComposited(
   clear_if_composited_did_clear_ = did_clear;
 }

+// =============================================================================
+// WEBGL FINGERPRINT PROTECTION
+// Uses FingerprintSessionManager for unified configuration
+// =============================================================================
+
+namespace {
+
+// Get spoofed WebGL vendor string
+String GetSpoofedWebGLVendor() {
+  auto& session = content::FingerprintSessionManager::GetInstance();
+  if (session.IsInitialized()) {
+    const std::string& vendor = session.GetWebGLVendor();
+    if (!vendor.empty()) {
+      return String::FromUTF8(vendor.c_str());
+    }
+  }
+  return "Intel Inc.";  // Fallback
+}
+
+// Get spoofed WebGL renderer string
+String GetSpoofedWebGLRenderer() {
+  auto& session = content::FingerprintSessionManager::GetInstance();
+  if (session.IsInitialized()) {
+    const std::string& renderer = session.GetWebGLRenderer();
+    if (!renderer.empty()) {
+      return String::FromUTF8(renderer.c_str());
+    }
+  }
+  return "Intel(R) UHD Graphics";  // Fallback
+}
+
+// Add noise to WebGL pixel data (for readPixels)
+void AddWebGLPixelNoise(uint8_t* data, size_t data_size) {
+  auto& session = content::FingerprintSessionManager::GetInstance();
+
+  float noise_level = session.GetWebGLReadPixelsNoise();
+  uint64_t seed = session.GetSessionSeed();
+
+  if (noise_level <= 0) {
+    return;
+  }
+
+  std::mt19937_64 gen(seed + 0x5742474C);  // Different seed offset for WebGL
+  std::uniform_int_distribution<int> noise_dist(-2, 2);
+
+  size_t pixel_count = data_size / 4;
+  size_t noise_count = static_cast<size_t>(pixel_count * noise_level);
+
+  for (size_t i = 0; i < noise_count; i++) {
+    size_t pixel_idx = gen() % pixel_count;
+    size_t byte_idx = pixel_idx * 4;
+
+    for (int c = 0; c < 3; c++) {  // RGB only
+      int val = data[byte_idx + c] + noise_dist(gen);
+      if (val < 0) val = 0;
+      if (val > 255) val = 255;
+      data[byte_idx + c] = static_cast<uint8_t>(val);
+    }
+  }
+}
+
+}  // namespace

 ScriptValue WebGLRenderingContextBase::getParameter(ScriptState* script_state,
                                                      GLenum pname) {
   if (isContextLost())
     return ScriptValue::CreateNull(script_state->GetIsolate());

+  // ==========================================================================
+  // WEBGL PARAMETER SPOOFING
+  // Override specific parameters for fingerprint protection
+  // ==========================================================================
+
+  // Handle WEBGL_debug_renderer_info extension parameters
+  if (pname == GL_VENDOR) {
+    return WebGLAny(script_state, GetSpoofedWebGLVendor());
+  }
+
+  if (pname == GL_RENDERER) {
+    return WebGLAny(script_state, GetSpoofedWebGLRenderer());
+  }
+
+  // UNMASKED variants from WEBGL_debug_renderer_info extension
+  if (pname == 0x9245 /* GL_UNMASKED_VENDOR_WEBGL */) {
+    return WebGLAny(script_state, GetSpoofedWebGLVendor());
+  }
+
+  if (pname == 0x9246 /* GL_UNMASKED_RENDERER_WEBGL */) {
+    return WebGLAny(script_state, GetSpoofedWebGLRenderer());
+  }
+
   switch (pname) {
     case GL_ACTIVE_TEXTURE:
       return GetUnsignedIntParameter(script_state, pname);
@@ -2900,6 +2987,13 @@ void WebGLRenderingContextBase::ReadPixels(
     return;
   }

+  // ==========================================================================
+  // WEBGL READPIXELS FINGERPRINT PROTECTION
+  // Add subtle noise to prevent fingerprinting via WebGL readPixels
+  // ==========================================================================
+  if (type == GL_UNSIGNED_BYTE) {
+    AddWebGLPixelNoise(static_cast<uint8_t*>(pixels->Data()), pixels->byteLength());
+  }
 }

diff --git a/third_party/blink/renderer/modules/webgl/webgl2_rendering_context_base.cc b/third_party/blink/renderer/modules/webgl/webgl2_rendering_context_base.cc
index ccccccc..ddddddd 100644
--- a/third_party/blink/renderer/modules/webgl/webgl2_rendering_context_base.cc
+++ b/third_party/blink/renderer/modules/webgl/webgl2_rendering_context_base.cc
@@ -60,6 +60,10 @@
 #include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
 #include "ui/gfx/geometry/rect.h"

+// Fingerprint protection integration
+#include "content/browser/fingerprint/fingerprint_session_manager.h"
+#include <random>
+

 namespace blink {

@@ -1500,6 +1504,54 @@ void WebGL2RenderingContextBase::texStorage3D(GLenum target,
   }
 }

+// =============================================================================
+// WEBGL2 FINGERPRINT PROTECTION
+// Same protection as WebGL1, using shared FingerprintSessionManager
+// =============================================================================
+
+namespace {
+
+void AddWebGL2PixelNoise(uint8_t* data, size_t data_size) {
+  auto& session = content::FingerprintSessionManager::GetInstance();
+
+  float noise_level = session.GetWebGLReadPixelsNoise();
+  uint64_t seed = session.GetSessionSeed();
+
+  if (noise_level <= 0) {
+    return;
+  }
+
+  std::mt19937_64 gen(seed + 0x5742474C32);  // WebGL2 specific offset
+  std::uniform_int_distribution<int> noise_dist(-2, 2);
+
+  size_t pixel_count = data_size / 4;
+  size_t noise_count = static_cast<size_t>(pixel_count * noise_level);
+
+  for (size_t i = 0; i < noise_count; i++) {
+    size_t pixel_idx = gen() % pixel_count;
+    size_t byte_idx = pixel_idx * 4;
+
+    for (int c = 0; c < 3; c++) {
+      int val = data[byte_idx + c] + noise_dist(gen);
+      if (val < 0) val = 0;
+      if (val > 255) val = 255;
+      data[byte_idx + c] = static_cast<uint8_t>(val);
+    }
+  }
+}
+
+}  // namespace
+
 void WebGL2RenderingContextBase::readPixels(
     GLint x,
     GLint y,
@@ -1550,6 +1602,14 @@ void WebGL2RenderingContextBase::readPixels(
     return;
   }

+  // ==========================================================================
+  // WEBGL2 READPIXELS FINGERPRINT PROTECTION
+  // ==========================================================================
+  if (type == GL_UNSIGNED_BYTE && pixels) {
+    MaybeShared<DOMArrayBufferView> view(pixels);
+    AddWebGL2PixelNoise(static_cast<uint8_t*>(view->Data()), view->byteLength());
+  }
+
   ClearIfComposited(kClearCallerReadPixels);
   ContextGL()->ReadPixels(x, y, width, height, format, type, offset);
 }

diff --git a/third_party/blink/renderer/modules/webgl/webgl_debug_renderer_info.cc b/third_party/blink/renderer/modules/webgl/webgl_debug_renderer_info.cc
index eeeeeee..fffffff 100644
--- a/third_party/blink/renderer/modules/webgl/webgl_debug_renderer_info.cc
+++ b/third_party/blink/renderer/modules/webgl/webgl_debug_renderer_info.cc
@@ -8,6 +8,9 @@
 #include "third_party/blink/renderer/modules/webgl/webgl_rendering_context_base.h"
 #include "third_party/blink/renderer/platform/bindings/exception_state.h"

+// Fingerprint protection
+#include "content/browser/fingerprint/fingerprint_session_manager.h"
+

 namespace blink {

@@ -31,6 +34,14 @@ WebGLExtensionName WebGLDebugRendererInfo::GetName() const {

 bool WebGLDebugRendererInfo::Supported(WebGLRenderingContextBase* context) {
   // ==========================================================================
-  // WEBGL DEBUG RENDERER INFO EXTENSION
+  // WEBGL DEBUG RENDERER INFO EXTENSION - ALWAYS ENABLED
   // We allow this extension because we spoof the values anyway
+  // Disabling it would be a detection vector itself
   // ==========================================================================
   return true;
 }
